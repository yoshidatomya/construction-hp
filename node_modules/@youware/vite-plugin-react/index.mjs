import g, { resolve as m, dirname as h } from "path";
import { createRequire as y } from "module";
import { parse as E } from "@babel/parser";
import * as e from "@babel/types";
import { existsSync as S, mkdirSync as w, copyFileSync as v } from "fs";
const j = {
  sourceType: "module",
  allowImportExportEverywhere: !0,
  ranges: !0,
  tokens: !0,
  plugins: [
    // 基础语法支持
    "jsx",
    "typescript"
  ]
};
function b(t, n) {
  const i = g.relative(process.cwd(), n), r = t.loc, a = r ? `${r.start.line}:${r.start.column}` : "unknown", s = `${i}@${a}`;
  return Buffer.from(s, "utf8").toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
const x = y(import.meta.url), A = x("@babel/traverse").default, I = x("@babel/generator").default;
function _(t) {
  const n = t.children;
  if (n.length !== 1)
    return !1;
  const i = n[0];
  return e.isJSXText(i) ? i.value.trim().length > 0 : !1;
}
function J(t) {
  return !e.isJSXIdentifier(t.openingElement.name) || t.openingElement.name.name.toLowerCase() !== "img" ? !1 : !!t.openingElement.attributes.find(
    (r) => e.isJSXAttribute(r) && e.isJSXIdentifier(r.name) && r.name.name === "src" && e.isStringLiteral(r.value)
  );
}
function X(t) {
  const n = t.openingElement.attributes.find(
    (i) => e.isJSXAttribute(i) && e.isJSXIdentifier(i.name) && i.name.name === "style"
  );
  if (!n)
    return !0;
  if (e.isJSXAttribute(n) && e.isJSXExpressionContainer(n.value)) {
    const i = n.value.expression;
    return e.isObjectExpression(i) ? i.properties.every((r) => {
      if (e.isObjectProperty(r)) {
        const a = e.isIdentifier(r.key) || e.isStringLiteral(r.key), s = e.isStringLiteral(r.value) || e.isNumericLiteral(r.value);
        return a && s;
      }
      return !1;
    }) : !1;
  }
  return !1;
}
function C(t) {
  return !e.isJSXIdentifier(t.openingElement.name) || t.openingElement.name.name.toLowerCase() !== "a" ? !1 : !!t.openingElement.attributes.find(
    (r) => e.isJSXAttribute(r) && e.isJSXIdentifier(r.name) && r.name.name === "href" && e.isStringLiteral(r.value)
  );
}
const L = /* @__PURE__ */ new Set([
  // Main root
  "html",
  // Document metadata
  "base",
  "head",
  "link",
  "meta",
  "style",
  "title",
  // Sectioning root
  "body",
  // Content sectioning
  "address",
  "article",
  "aside",
  "footer",
  "header",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hgroup",
  "main",
  "nav",
  "section",
  "search",
  // Text content
  "blockquote",
  "dd",
  "div",
  "dl",
  "dt",
  "figcaption",
  "figure",
  "hr",
  "li",
  "menu",
  "ol",
  "p",
  "pre",
  "ul",
  // Inline text semantics
  "a",
  "abbr",
  "b",
  "bdi",
  "bdo",
  "br",
  "cite",
  "code",
  "data",
  "dfn",
  "em",
  "i",
  "kbd",
  "mark",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "time",
  "u",
  "var",
  "wbr",
  // Image and multimedia
  // Note: 'audio' may conflict with three.js Audio in @react-three/fiber, but HTML audio with
  // controls attribute is more commonly used and has visible UI that users may want to edit
  "area",
  "audio",
  "img",
  "map",
  "track",
  "video",
  // Embedded content
  "embed",
  "iframe",
  "object",
  "param",
  "picture",
  "portal",
  "source",
  // SVG and MathML
  "svg",
  "math",
  // Scripting
  "canvas",
  "noscript",
  "script",
  // Demarcating edits
  "del",
  "ins",
  // Table content
  "caption",
  "col",
  "colgroup",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "tr",
  // Forms
  "button",
  "datalist",
  "fieldset",
  "form",
  "input",
  "label",
  "legend",
  "meter",
  "optgroup",
  "option",
  "output",
  "progress",
  "select",
  "textarea",
  // Interactive elements
  "details",
  "dialog",
  "summary",
  // Web Components
  "slot",
  "template"
]);
function T(t) {
  const n = t.openingElement.name;
  if (e.isJSXMemberExpression(n) || e.isJSXNamespacedName(n) || !e.isJSXIdentifier(n))
    return !1;
  const i = n.name;
  return i[0] === i[0].toUpperCase() ? !1 : L.has(i);
}
function k(t) {
  return t.children.some((n) => e.isJSXText(n) && n.value.trim().length > 0);
}
function N(t, n) {
  t.children = t.children.map((i) => {
    if (e.isJSXText(i) && i.value.trim()) {
      const a = b(i, n);
      return e.jsxElement(
        e.jsxOpeningElement(
          e.jsxIdentifier("span"),
          [
            e.jsxAttribute(e.jsxIdentifier("data-yw"), e.stringLiteral(a)),
            e.jsxAttribute(e.jsxIdentifier("data-yw-t"), null),
            e.jsxAttribute(e.jsxIdentifier("data-yw-auto"), null)
            // 标记为自动包装
          ],
          !1
        ),
        e.jsxClosingElement(e.jsxIdentifier("span")),
        [e.jsxText(i.value)],
        !1
      );
    }
    return i;
  });
}
function P(t, n, i) {
  const r = t.openingElement.attributes;
  r.push(e.jsxAttribute(e.jsxIdentifier("data-yw"), e.stringLiteral(n))), _(t) ? r.push(e.jsxAttribute(e.jsxIdentifier("data-yw-t"), null)) : k(t) && N(t, i), J(t) && r.push(e.jsxAttribute(e.jsxIdentifier("data-yw-i"), null)), X(t) && r.push(e.jsxAttribute(e.jsxIdentifier("data-yw-s"), null)), C(t) && r.push(e.jsxAttribute(e.jsxIdentifier("data-yw-l"), null));
}
function M(t, n) {
  try {
    const i = E(t, j);
    let r = !1;
    if (A(i, {
      JSXElement(a) {
        const s = a.node;
        if (!T(s) || s.openingElement.attributes.some(
          (u) => e.isJSXAttribute(u) && e.isJSXIdentifier(u.name) && u.name.name === "data-yw-auto"
        ))
          return;
        const c = b(s, n);
        P(s, c, n), r = !0;
      }
    }), r) {
      const a = I(i, {
        retainLines: !0,
        compact: !1
      });
      return {
        code: a.code,
        map: a.map
      };
    }
    return null;
  } catch (i) {
    return console.warn(`Error processing JSX elements in file ${n}:`, i), null;
  }
}
const O = (t, n) => {
  const i = g.basename(t);
  return n.some((r) => i === r);
}, R = () => `;
// Visual Editor HMR Bridge - Auto-injected
if (import.meta.hot) {
  import.meta.hot.on('vite:beforeUpdate', (payload) => {
    if (window.__visualEditorCommunication) {
      window.__visualEditorCommunication.handleViteBeforeUpdate(payload);
    }
  });
  
  import.meta.hot.on('vite:afterUpdate', (payload) => {
    if (window.__visualEditorCommunication) {
      window.__visualEditorCommunication.handleViteAfterUpdate(payload);
    }
  });
}
`, p = (t) => {
  let n = t.replace(/\*\*/g, "___DOUBLESTAR___");
  return n = n.replace(/[.+^${}()|[\]\\]/g, "\\$&"), n = n.replace(/\*/g, "[^/]*"), n = n.replace(/___DOUBLESTAR___/g, ".*"), new RegExp(`^${n}$`);
}, $ = (t, n, i) => i.some((s) => p(s).test(t)) ? !1 : n.some((s) => p(s).test(t));
function B(t = {}) {
  const {
    include: n = ["**/*.tsx", "**/*.jsx"],
    exclude: i = ["node_modules/**", "**/dist/**"],
    entryFiles: r = ["main.tsx", "main.ts", "main.jsx", "main.js"]
  } = t;
  return {
    name: "visual-editor-plugin",
    enforce: "pre",
    transform(a, s) {
      const l = O(s, r), c = s.endsWith(".tsx") || s.endsWith(".jsx");
      if (!l && !c || !(l || $(s, n, i)))
        return null;
      try {
        let o = a, d = null;
        if (!l || c) {
          const f = M(a, s);
          f && (o = f.code, d = f.map);
        }
        return l && (o += R()), o !== a ? {
          code: o,
          map: d
        } : null;
      } catch (o) {
        return console.warn(`Error processing file ${s}:`, o), null;
      }
    }
  };
}
function U() {
  return {
    name: "youware-manifest",
    buildStart() {
      try {
        const t = m(process.cwd(), "yw_manifest.json"), n = m(process.cwd(), "public", "yw_manifest.json");
        S(t) && (w(h(n), { recursive: !0 }), v(t, n));
      } catch (t) {
        console.error("❌ [Youware Manifest] Copy yw_manifest.json failed:", t);
      }
    }
  };
}
function D(t = {}) {
  const { enableReactVisualEditor: n = !!process.env.YOUWARE_SANDBOX, enableCopyManifest: i = !0 } = t, r = [];
  return i && r.push(U()), n && r.push(B(t.reactVisualEditorOptions)), {
    name: "youware-vite-plugin",
    enforce: "pre",
    // Combine buildStart hooks
    buildStart(a) {
      for (const s of r)
        s.buildStart && typeof s.buildStart == "function" && s.buildStart.call(this, a);
    },
    // Combine transform hooks
    transform(a, s) {
      let l = a, c = null;
      for (const u of r)
        if (u.transform && typeof u.transform == "function") {
          const o = u.transform.call(this, l, s);
          o && (typeof o == "string" ? l = o : o && typeof o == "object" && "code" in o && o.code && (l = o.code, "map" in o && (c = o.map)));
        }
      return l !== a ? { code: l, map: c } : null;
    }
  };
}
export {
  D as youwareVitePlugin
};
